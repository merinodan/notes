Linux Processes
---------------

Process - program running on the machine
ps - list running processes
PID - process ID
TTY - controlling terminal associated with the process
STAT - prpocess status code
TIME - total CPU usage time
CMD - name of executable/command

ps aux
a - displays all processes running
u - shows more details about the processes
x - lists all processes that don't have a TTY associated with it

top - shows realtime info about processes running on system instead of a snapshot

Regular terminal devices - native terminal device you can type into and send output to your system
Pseudoterminal devices - what we use to type in to the terminal, emulates terminals with shell terminal window. Denoted by PTS
Kernel is in charge of processes
Init - origin/root of all processes

When process dies, its parent process has to acknowledge the termination of the child process by using wait system call
    - Checks termination status of child process, which is created when process is ready to terminate (tells why its terminating)
    - Will have status 0 if successful
Orphan process - when a parent dies before a child process, init will perform the wait system call for these orphans so they can dies
Zombie process - Happens when child terminates but parent process hasn't called wait yet
    - Resources ares still freed, however there is still an entry for them in the process table
    - Cannot be killed, since they are technically dead. Can be reaped if parent eventually calls system wait call ("reaping")
    - You don't want to have too many zombie processes, since it takes up space on the process table which can prevent other services from running

Signal - notification to a process that something has happened
    - Examples:
        - User typing termination char (Ctrl-C) to kill, interrupt or suspend processes
        - Hardware/software issues can occur and kernel wants to notify the process
When a signal is generated by some event, it's then delivered to a process, it's considered pending until it's delivered
When process is ran, signal will be delivered
From there, process can do a multitude of things
    - Ignore the signal
    - "Catch" the signal and perform a specific handler routine
    - Process can be terminated, as opposed to normal exit system call
    - Block the signal, depending on the signal mask
Common signals
    - SIGHUP/HUP/1 - Hangup - ex. closing terminal window which had process running on it
    - SIGINT/INT/2 - interrupt - ex. ctrl-c and system will try to gracefully kill process
    - SIGKILL/KILL/9 - kill - kill, no cleanup
    - SIGSEGV/SEGV/11 - segmentation fault
    - SIGTERM/TERM/15 - software termination - kill process, but do some cleanup first - default for kill
    - SIGSTOP/STOP - stop/suspend a process
kill - kills a command with a PID, can specify a certain signal

nice - command that changes the niceness level of a process (value that shows how much priority a process has for the CPU [lower is more])

Process states (found in STAT column with ps aux):
    - R - running or runnable, waiting for CPU to process it
    - S - interruptible sleep, waiting for event to complete, such as input from terminal
    - D - uninterruptible sleep, processes that cannot be killed or interrupted iwth a signal
    - Z - zombie - terminated processes waiting to have their status collected
    - T - stopped - process that has been stopped or suspended

/proc - stores process information

appending an & to a command will run it in the background
jobs - will view the jobs in the background
bg - sends a job to the background
fg - brings job to foreground